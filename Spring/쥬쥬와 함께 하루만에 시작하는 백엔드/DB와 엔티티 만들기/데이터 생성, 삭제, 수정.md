# Controller, Service, Repository
![image](https://github.com/user-attachments/assets/dd9abe2d-431f-4dbc-91ad-fae669f55e52)

`MVC 패턴 처리 과정`
1. 클라이언트가 서버에 페이지를 요청한다.
2. Dispatcher Servlet은 사용자의 요청에 알맞는 @Controller를 찾는다.
3. 만약 DB데이터를 이용한 처리 과정이 없다면, 단순히 View를 보여주면 여기서 끝이다.
4. 만약 DB가 필요하다면 @Controller는 알맞은 @Service로 가서 비지니스 로직을 수행한다.
5. 수행하는 과정중 DB를 접근하기 위하여 @Repository에 요청하여 DB로 부터 필요한 값을 가져온다.
6. 순서대로 @Controller까지 결과값을 가지고 return을 하게 되며, Model에 담은 다음에 View를 찾아 보여준다.

### Component
`@Component` 어노테이션이 지정 되면 해당 객체는 Bean으로 등록되고 스프링 컨테이너가 해당 Bean을 관리하게 된다. 해당 기능을 스프링에서는 컴포넌트 스캔이라고 말한다.

### Controller
`@Controller` 라고 명시된 해당 클래스의 Mapping을 스캔한다. 

`@Controller`라고 명시가 되면, 해당 클래스는 `@Component`에 의해 자동으로 Bean이 등록된다. 클라이언트가 특정 요청을 하게 되면 처리하기 위해서 스프링은 제일 먼저 해당하는 Controller를 찾게 되는데 이때 `@Controller`라고 명시된 클래스들을 탐색한다. 그리고 난 다음에 Mapping주소가 일치하는 메소드의 내용을 실행하게 된다.

추가적으로 `@RestController`가 존재하는데, 이는 `@ResponseBody`를 사용한것과 동일하게 View를 반환하는게 아닌 객체(보통 JSON) 를 반환하게 된다.

### Service
`@Service` 라고 명시된 클래스는 비지니스 로직에 대한 정보들이 담겨 있어야 한다. 즉 사용자의 요청에 따라서 DB에 접근하여 데이터를 추가, 삭제, 수정, 선택과 같은 요청을 처리할 수 있어야 한다. 

### Repository
`@Repository` 어노테이션은 해당 객체는 DB에서 CRUD와 같은 명렁을 하게 되며, 간단하게 DB 접근이 가능한 객체라고 생각하면 된다.

# 데이터 생성하기
### Entity 클래스 생성
com.example.review 패키지에 model 패키지 생성 후 TestEntity 클래스를 생성한다.
```
@Getter
@Table(name = "test")
@Entity
public class TestEntity {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    private String name;
    private Integer age;

    public TestEntity(String name, Integer age){
        this.name = name;
        this.age = age;
    }
}
```
이 코드는 스프링 프레임워크와 JPA(Java Persistence API)를 사용하여 데이터베이스의 test 테이블과 매핑되는 엔티티 클래스를 정의한 것이다.
- `@Table(name = "test")` : 이 어노테이션은 이 엔티티 클래스가 데이터베이스의 test 테이블과 매핑된다는 것을 명시한다.
- `@Entity` : 이 클래스가 JPA 엔티티 클래스임을 선언한다. 즉, 이 클래스는 데이터베이스의 테이블과 매핑되어 객체와 관계형 데이터베이스의 데이터를 변환할 수 있게 된다.
- `private long id;` : 엔티티의 기본 키(primary key)를 나타내는 필드이다. @Id 어노테이션을 통해 이 필드가 기본 키임을 명시한다.
- `@GeneratedValue(strategy = GenerationType.IDENTITY)` : 이 어노테이션은 id 필드가 자동으로 생성됨을 나타낸다. GenerationType.IDENTITY는 데이터베이스에서 자동으로 증가하는 값(보통 자동 증가 필드)을 사용하여 기본 키 값을 생성하는 전략이다.
- `private String name; 및 private Integer age;` : name과 age는 test 테이블의 컬럼과 매핑되는 필드들이다. 

![image](https://github.com/user-attachments/assets/f22f0cb4-b21d-438d-978e-d3e78fcd086e)

h2-console에 들어가면 test 테이블이 있는 것을 확인할 수 있다.

### Repository 생성
com.example.review 패키지에 repository 패키지 생성 후 TestRepository 클래스를 생성한다.

```
public interface TestRepository extends JpaRepository<TestEntity, Long> {
}
```
`JpaRepository`는 스프링 데이터 JPA에서 제공하는 인터페이스로, 기본적인 CRUD(Create, Read, Update, Delete) 작업을 지원하는 메서드를 제공한다. `TestRepository`는 `JpaRepository`를 확장(상속)한 인터페이스로, `TestEntity` 엔티티와 기본 키 타입이 Long인 엔티티 리포지토리이다. 이 인터페이스를 통해 `TestEntity`에 대한 데이터베이스 작업(save(), findById(), findAll(), deleteById() 등)을 수행할 수 있다. 

결론적으로, `TestRepository`는 `TestEntity` 엔티티의 데이터베이스 작업을 간편하게 처리하기 위한 인터페이스로, 스프링 데이터 JPA의 자동 구현 기능을 통해 CRUD 작업을 쉽게 수행할 수 있게 해준다.

### Service 생성
com.example.review 패키지에 Service 패키지 생성 후 TestService 클래스를 생성한다.
```
@AllArgsConstructor
@Service
public class TestService {
    private final TestRepository testRepository;

    public void create(String name, Integer age){
        TestEntity testEntity = new TestEntity(name, age);
        testRepository.save(testEntity);
    }
}
```
- `@Service` : 이 어노테이션은 이 클래스가 서비스 계층의 컴포넌트임을 나타낸다. 서비스 계층은 비즈니스 로직을 처리하는 곳이다.
- `private final TestRepository testRepository;` : TestRepository는 TestService 클래스의 의존성으로 주입된 필드이다. final 키워드를 사용하여 이 필드가 초기화된 후 변경되지 않음을 보장한다. 이 필드를 통해 데이터베이스와 상호작용할 수 있다.
- `public void create(String name, Integer age) {` : create 메서드는 새로운 TestEntity 객체를 생성하고 이를 데이터베이스에 저장하는 기능을 수행한다.
- `TestEntity testEntity = new TestEntity(name, age);` : name과 age를 매개변수로 받아 TestEntity 객체를 생성한다. TestEntity 클래스의 생성자를 호출하여 객체를 초기화한다.
- `testRepository.save(testEntity);` : testRepository의 save 메서드를 호출하여 생성한 TestEntity 객체를 데이터베이스에 저장한다. save 메서드는 JpaRepository에서 제공하는 메서드로, 엔티티를 저장하거나 업데이트하는 데 사용된다.

`TestService`는 비즈니스 로직을 처리하는 서비스 계층의 클래스이다. 여기에서는 create 메서드를 통해 `TestEntity` 객체를 생성하고, `TestRepository`를 사용하여 이를 데이터베이스에 저장하는 역할을 한다.

